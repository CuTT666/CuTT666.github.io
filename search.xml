<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[maven项目SSM整合中MySQL8对应Druid版本问题以及dataSource的配置]]></title>
    <url>%2F2019%2F09%2F20%2FSSM%E6%95%B4%E5%90%88%E4%B8%ADMySQL8%E5%AF%B9%E5%BA%94Druid%E7%89%88%E6%9C%AC%E9%97%AE%E9%A2%98%E4%BB%A5%E5%8F%8AdataSource%E7%9A%84%E9%85%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[版本能兼容的pom.xml的写法 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.1.10&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.17&lt;/version&gt;&lt;/dependency&gt; applicationContext.xml中配置dataSource的写法123456&lt;bean id="dataSource" class="com.alibaba.druid.pool.DruidDataSource" init-method="init" destroy-method="close"&gt; &lt;property name="driverClassName" value="com.mysql.cj.jdbc.Driver" /&gt; &lt;property name="url" value="jdbc:mysql://localhost:3366/jw_system?useUnicode=true&amp;amp;characterEncoding=utf8&amp;amp;autoReconnect=true&amp;amp;useSSL=false&amp;amp;serverTimezone=UTC" /&gt; &lt;property name="username" value="root" /&gt; &lt;property name="password" value="123" /&gt;&lt;/bean&gt;]]></content>
      <categories>
        <category>error</category>
      </categories>
      <tags>
        <tag>SSM</tag>
        <tag>maven</tag>
        <tag>error</tag>
        <tag>异常</tag>
        <tag>xml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Mybatis Generator自动生成代码]]></title>
    <url>%2F2019%2F09%2F19%2FMybatis-Generator%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[自动生成代码步骤 新建web项目 导入mybatis.jar；mybatis-generator-core.jar；mysql-connector-java.jar。 注意，mysql-connector-java.jar需要在项目根目录再导入一份并buildpath。为了后面的配置文件中&lt;classPathEntry location=&quot;mysql-connector-java-8.0.17.jar&quot; /&gt;不出错。 再src目录下加Generate.java 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import java.io.File;import java.io.IOException;import java.io.InputStream;import java.net.URL;import java.sql.SQLException;import java.util.ArrayList;import java.util.List;import org.mybatis.generator.api.MyBatisGenerator;import org.mybatis.generator.config.Configuration;import org.mybatis.generator.config.xml.ConfigurationParser;import org.mybatis.generator.exception.InvalidConfigurationException;import org.mybatis.generator.exception.XMLParserException;import org.mybatis.generator.internal.DefaultShellCallback;import sun.nio.cs.Surrogate.Generator;public class Generate &#123; public static void main(String[] args) &#123; List&lt;String&gt; warnings = new ArrayList&lt;String&gt;(); boolean overwrite = true;//如果已经生成过了是否进行覆盖 String genCfg = "/generatorConfig2.xml";//配置文件的路径:可以放到自己喜欢的目录下面 URL url = Generator.class.getResource(genCfg); String file = url.getFile(); File configFile = new File(file); InputStream is = Generator.class.getResourceAsStream(genCfg); //System.out.println(is==null); ConfigurationParser cfgParser = new ConfigurationParser(warnings);//配置文件解析器 Configuration config = null; try &#123; //config = cfgParser.parseConfiguration(is); config = cfgParser.parseConfiguration(configFile); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (XMLParserException e) &#123; e.printStackTrace(); &#125; DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator generator = null; try &#123; generator = new MyBatisGenerator(config, callback, warnings); &#125; catch (InvalidConfigurationException e) &#123; e.printStackTrace(); &#125; try &#123; generator.generate(null); System.out.println("mybatis 代码生成成功。。。"); for(String warning: warnings) &#123; System.out.println(warning); &#125; &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 再src目录下加generatorConfig.xml 注意： connectionURL中，如果mysql版本是8.0以上，后面要加?serverTimezone=UTC 为防止生成很多文件，在&lt;jdbcConnection&gt;标签中添加&lt;property name=&quot;nullCatalogMeansCurrent&quot; value=&quot;true&quot; /&gt; 去掉注释： suppressDate是去掉生成日期那行注释 suppressAllComments是去掉所有的注解 1234&lt;commentGenerator&gt; &lt;property name="suppressDate" value="true"/&gt; &lt;property name="suppressAllComments" value="true" /&gt;&lt;/commentGenerator&gt; 总的代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?xml version="1.0" encoding="UTF-8"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN" "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;&lt;generatorConfiguration&gt; &lt;!-- 利用自己写java代码来调用 --&gt; &lt;classPathEntry location="mysql-connector-java-8.0.17.jar" /&gt; &lt;context id="MBG" targetRuntime="MyBatis3" defaultModelType="flat"&gt; &lt;property name="beginningDelimiter" value="`" /&gt; &lt;property name="endingDelimiter" value="`" /&gt; &lt;commentGenerator&gt; &lt;property name="suppressDate" value="true" /&gt; &lt;property name="suppressAllComments" value="true" /&gt; &lt;/commentGenerator&gt; &lt;jdbcConnection driverClass="com.mysql.cj.jdbc.Driver" connectionURL="jdbc:mysql://localhost:3366/hellomysql?serverTimezone=UTC" userId="root" password="123"&gt; &lt;property name="nullCatalogMeansCurrent" value="true" /&gt; &lt;/jdbcConnection&gt; &lt;javaModelGenerator targetPackage="com.qq.model" targetProject="src"&gt; &lt;property name="trimStrings" value="true" /&gt; &lt;/javaModelGenerator&gt; &lt;sqlMapGenerator targetPackage="com.qq.mapper" targetProject="src"&gt;&lt;/sqlMapGenerator&gt; &lt;javaClientGenerator type="XMLMAPPER" targetPackage="com.qq.mapper" targetProject="src"&gt;&lt;/javaClientGenerator&gt; &lt;table tableName="%"&gt; &lt;generatedKey column="id" sqlStatement="MySql" /&gt; &lt;/table&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 运行Generate.java]]></content>
      <categories>
        <category>Mybatis</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Mybatis</tag>
        <tag>Java</tag>
        <tag>框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络认识与socket]]></title>
    <url>%2F2019%2F09%2F12%2F%E7%BD%91%E7%BB%9C%E8%AE%A4%E8%AF%86%E4%B8%8Esocket%2F</url>
    <content type="text"><![CDATA[网络编程概述 网络协议 网络协议为计算机网络中进行数据交换而建立的规则、标准或约定的集合。 常用协议：TCP/IP协议；UDP协议。 TCP/IP协议的层次结构比较简单，共分为四层：应用层、传输层、网络层和链路层。 链路层：链路层是用于定义物理传输通道，通常是对某些网络连接设备的驱动协议，例如针对光纤、网线提供的驱动。 网络层：网络层是整个TCP/IP协议的核心，它主要用于将传输的数据进行分组，将分组数据发送到目标计算机或者网络。 IP（Internet protocol）协议： 它为TCP、UDP、ICMP等协议提供传输的通路。 使不同的子网间能够传输数据。 传输层：主要使网络程序进行通信，在进行网络通信时，可以采用TCP协议，也可以采用UDP协议。 TCP（Transmission Control Protocol）: 传输控制协议：最出名的 在整个过程中保持连接。 一次请求，一次响应。 点对点的传输协议。 UDP （User Datagram Protocol）：用户数据报协议 可以一对一、一对多、多对一、多对多 在通信的整个过程中不需要保持连接 不保证数据传输的可靠性和有序性 在通信的整个过程中不需要保持连接 只能传输64K 应用层：主要负责应用程序的协议，例如HTTP协议（超文本传输协议）、FTP协议等。 HTTP/HTTPS：超文本传输协议。 FTP： 文件传输协议。 网络中的三要素 IP地址 ：分为网络地址与主机地址 端口号： 0~65535,不同进程的标识，通过360可以查看端口号 协议： UDP 与 TCP IP地址与端口号 每台计算机都有一个标识号，而IP地址就是这个标识号。 端口号表示计算机中的程序的标识号。 UDP协议 接收端 123456789101112131415161718192021222324import java.net.DatagramPacket;import java.net.DatagramSocket;public class DatagramSet &#123; public static void main(String[] args) throws Exception &#123; //1.创建接收端并设置端口号 DatagramSocket datagramSet = new DatagramSocket(8888); //2.接受数据 //2.1创建一个数据包用于接收数据 byte[] bytes = new byte[1024]; DatagramPacket p = new DatagramPacket(bytes,bytes.length); //2.2使用seceive()方法接收到的数据放入p包中 System.out.println("开始接收！"); datagramSet.receive(p); //2.3使用getData()方法拿到数据包中的数据 byte[] data= p.getData(); //3.解析数据 String s = new String(data); System.out.println("接收到的数据："+s); datagramSet.close(); &#125;&#125; 发送端 123456789101112131415161718192021222324252627282930import java.io.IOException;import java.net.*;/** * 1.有发送端 * 2.发送数据 * 2.1 数据文件 * 2.2 ip * 2.3 端口号 * 3.发送 * 4.释放资源 */public class DatagramSocketTest &#123; public static void main(String[] args) throws IOException &#123; //1.创建发送端 DatagramSocket socket = new DatagramSocket(); //2.构造数据包 //2.1传输的数据byte[] byte[] bytes = "欢迎访问铜哥个人博客：https://cutt666.github.io".getBytes(); //2.2IP地址 InetAddress inet = InetAddress.getByName("192.168.2.144"); //2.3端口号 int port = 8888; //3.1发送数据 数据打包： DatagramPacket(byte buf[], int length, InetAddress address, int port) DatagramPacket p = new DatagramPacket(bytes,bytes.length,inet,port); //3.2发送数据包 .send(数据包) socket.send(p); System.out.println("发送成功！"); &#125;&#125; TCP协议 客户端 1234567891011121314151617181920import java.io.IOException;import java.io.OutputStream;import java.net.InetAddress;import java.net.Socket;public class ClientSocket &#123; public static void main(String[] args) throws IOException &#123; //创建客户端 Socket socket = new Socket(InetAddress.getByName("192.168.2.144"), 8888); //发送数据 OutputStream outputStream = socket.getOutputStream(); byte[] bytes = "你的菜需要捆吗？" .getBytes(); outputStream.write(bytes);// outputStream.close(); socket.close(); System.out.println("发送成功"); &#125;&#125; 服务端 123456789101112131415161718192021import java.io.IOException;import java.io.InputStream;import java.net.ServerSocket;import java.net.Socket;public class ServerTest &#123; public static void main(String[] args) throws IOException &#123; //创建服务器端 ServerSocket serverSocket = new ServerSocket(8888); //监听连接 System.out.println("开始监听"); Socket accept = serverSocket.accept(); System.out.println("连接成功"); //接收客户端传递的数据，拿到输入流对象 InputStream inputStream = accept.getInputStream(); byte[] bytes = new byte[1024]; int read = inputStream.read(bytes); //解析数据 System.out.println(new String(bytes,0,read)); &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
        <tag>网络</tag>
        <tag>socket</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[tomcat端口被占用]]></title>
    <url>%2F2019%2F08%2F13%2Ftomcat%E7%AB%AF%E5%8F%A3%E8%A2%AB%E5%8D%A0%E7%94%A8%2F</url>
    <content type="text"><![CDATA[Several ports (8005, 8080, 8009) required by Tomcat v8.5 Server at localhost are already in use… 当Run on Server后报这种错误后，说明tomcat端口号被占用。 此时，重启电脑可以解决问题，但是太麻烦了没有必要。 下面介绍另一种方法： win + R ，输入cmd进入命令行界面 输入netstat -ano|findstr 8080查看占用8080端口号的进程 输入taskkill /pid 19972 /f 将显示的进程号结束掉 最后再重启tomcat就行了。]]></content>
      <categories>
        <category>error</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>error</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[集合]]></title>
    <url>%2F2019%2F08%2F13%2F%E9%9B%86%E5%90%88%2F</url>
    <content type="text"><![CDATA[集合 Java中非常重要的工具类，用来存储对象的容器，也成为容器类。 不但可以存放数量不等的对象，还能存放具有映射关系的键值对 原本数组也是和集合差不多的含义，但是java默认的数组的功能有限（如定长），特使用集合来解决更加特殊的需要，即当你事先不知道要存放数据的个数，或者你需要一种比数组下标存取机制更灵活的方法时，你就需要用到集合类。 集合与数组 数组：创建时，元素个数就确定了。 集合：可以动态增加、减少元素。 l 数组Array：访问速度快； 增、删 的速度慢。 l 链表Link：增、删 的速度快， 访问的速度慢。 Arrays.sort(数组) 是为数组排序而用的； Collections.sort(List list) 是为集合排序而用； Collection和Map Collection定义在java.util包下，是整个Java类中保存单值集合的最大父接口。一般使用其子接口List和Set。 Set（集）接口：强调元素不能重复，即唯一性；但无序 List（列表）接口：强调元素是有序的，但可以重复，即不唯一性 Map（映射）接口：演化成（键，值）对，：键：唯一，无序；值：不唯一,无序。（也称映射）； Hashset 如果对象和已有的元素的地址相同（==），则add（）不添加 会调用对象的HashCode（）； 如果发现和已有所有元素的HashCode（）值都不同，就认为是不同对象，则add（）加入 如果发现和已有某个元素的Hash Code（）值相同，那么就再使用equals（）来判断，如果比较时得到true，则不添加，反之添加。 HashCode（）是计算对象的特征值，是一个整数，Java中每个HashCode的值都不同 用hashCode计算出对象的特征值 123456//用特征值减少了比较次数，例如特征值定义为id.length()Person p1 = new Person("小明",12,"5001111"); //特征值7Person p1 = new Person("小红",12,"5001112"); //特征值7Person p1 = new Person("小a",15,"5001155"); //特征值7Person p1 = new Person("小明",12,"5001"); //特征值4 如果对象的特征值不同，那么肯定是不同的对象，这样就可以添加进集合 如果特征值相同，那么就要进一步判断，每个对象比较，Java中用equals（）； Set1234567891011121314151617181920212223HashSet&lt;Integer&gt; hs = new HashSet&lt;Integer&gt;();Integer i1 = new Integer(5);Integer i2 = new Integer(15);Integer i3 = new Integer(25);hs.add(i1);hs.add(i2);hs.add(i3); //唯一性hs.add(i1); //唯一性for (Object object : hs) &#123; System.out.println(object);&#125;System.out.println("~~~~~~~~~~~~~~~~");ArrayList&lt;Integer&gt; al= new ArrayList&lt;Integer&gt;(); //可重复了al.add(i1);al.add(i2);al.add(i3);al.add(i1);al.add(i2);al.add(i3);for (Object object : al) &#123; System.out.println(object);&#125; List以及遍历12345678910111213141516171819202122232425ArrayList&lt;String&gt; al = new ArrayList&lt;String&gt;(); //泛型：类型被参数化，类型可以被传递al.add("a");al.add("b");al.add("c");//al.add(1);for (Object object : al) &#123; System.out.print(object);&#125;System.out.println();//利用size（）和get（）方法，数组用lengthSystem.out.println(al.size());for(int i = 0;i&lt;al.size();i++) &#123; System.out.print(al.get(i));&#125;System.out.println();//利用迭代Iterator对象 单向Iterator&lt;String&gt; it = al.iterator();while(it.hasNext()) &#123; Object t = it.next(); System.out.print(t);&#125; Map12345678910111213141516171819202122232425//键值对 HashMap&lt;String, Integer&gt; hm = new HashMap&lt;String, Integer&gt;(); hm.put("a", 5); hm.put("b", 15); hm.put("c", 25); hm.put("d", 35); //3.使用Entry对象 //内部类 for (Map.Entry&lt;String, Integer&gt; one : hm.entrySet()) &#123;// System.out.println(one.getKey()+"="+one.getValue()); System.out.println(one); &#125; // System.out.println(hm.get("a"));// System.out.println(hm.get("c")); //通过values（）方法获取值的集合 for (Integer one : hm.values()) &#123; System.out.println(one); &#125; //2.通过keySet（）获取键集合 for (String string : hm.keySet()) &#123; System.out.println(string); &#125; 遍历中删除123456789101112131415161718CopyOnWriteArrayList&lt;String&gt; al = new CopyOnWriteArrayList&lt;String&gt;();al.add("a");al.add("b");al.add("c");al.add("d");al.add("e");//删除c，但在这个遍历中仍会打印出来for (String string : al) &#123; if(string.equals("c")) al.remove(string); System.out.println(string);&#125;System.out.println("----------------------");//遍历，已删除cfor (String string : al) &#123; System.out.println(string);&#125; 通过枚举遍历hashTable12345678910111213141516171819Hashtable&lt;String, Integer&gt; ht = new Hashtable&lt;String, Integer&gt;(); ht.put("a", 1);ht.put("b", 2);ht.put("c", 3);ht.put("d", 4);//枚举Enumeration&lt;String&gt; em = ht.keys();while(em.hasMoreElements()) &#123; System.out.print(em.nextElement()+",");&#125;System.out.println();Enumeration&lt;Integer&gt; ele = ht.elements();while(ele.hasMoreElements()) &#123; System.out.print(ele.nextElement()+",");&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
        <tag>集合</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript中不同数据类型的运算]]></title>
    <url>%2F2019%2F08%2F12%2FJavaScript%E4%B8%AD%E4%B8%8D%E5%90%8C%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E7%9A%84%E8%BF%90%E7%AE%97%2F</url>
    <content type="text"><![CDATA[不同类型的变量进行运算 1234567891011121314151617181920212223242526271 + '2' //'12'1 + 2 + '3' //'33'1 + null //11 + true //1+1=21 + false //1+0=1true + true //2null + false //0+0=01 + 's' //'1s''s' + null //'snull''s' + true // 'strue'null + undefined //NaN1 + undefined //NaN's' + undefined //'sundefined'1 + undefined + 's' //NaNs 数据前有‘+’，可以让字符串转化为数字12+'1'+1 //2+'s'+2 //NaN]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[反射笔记]]></title>
    <url>%2F2019%2F08%2F10%2F%E5%8F%8D%E5%B0%84%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[反射概述 使用一种技术在程序运行时就能去操作Java对象的属性，方法，构造方法等。 可以获取谁的字节码对象？ 自定义类，java类 构造器的 方法 全局变量 基本数据类型8个 enum 数组 接口 如何获取？ 类名.class Class.forName(完全限定名) 对象名.getClass() 操作构造方法 获取构造方法对象。目的：创建实例对象 class.getConstructor(); 注意：获取公共的构造方法对象 class.getDeclaredConstructor(); 注意： 获取私有和公共的构造方法对象 构造方法对象的操作 newInstance() 通过构造方法对象创建实例对象 注意：如果构造方法对象是私有的 修改访问权限 Constructor.setAccessible(true); 表示将访问权限修饰符改为public 1234567Class clz = Singer.class; //获得类的字节码对象//获得构造方法字节码对象Constructor cons = clz.getDeclaredConstructor(String.class);//设计权限cons.setAccessible(true);Singer sg = (Singer) cons.newInstance("邓紫棋");System.out.println("名字："+sg.name); 获取方法对象。目的：使用方法 class.getMethod(&quot;方法名&quot;，参数类型.class); 只能获取公有的 class.getDeclaredMethod(&quot;方法名&quot;，参数类型.class); 方法对象的操作 method.setAccessible(true); 修改权限 method.invoke(对象变量名，实参列表); method.getName(); 获取方法的名字 method.getParameters(); 获取方法的参数列表 12345678910111213141516171819202122//获得类的字节码对象Class clz = Singer.class;//获得类对象Singer s = (Singer) clz.newInstance();//获得方法字节码对象Method mt = clz.getDeclaredMethod("eat", Date.class);//设计权限mt.setAccessible(true);//使用Invoke来调用mt.invoke(s,new Date());//获取类中的方法名以及参数Method[] method = clz.getDeclaredMethods();for (Method e:method) &#123; System.out.println(e.getName()); Parameter[] p = e.getParameters(); for (Parameter f: p) &#123; System.out.println(f); &#125;&#125; 获取字段 class.getField(字段名) class.getDeclaredField(字段名) 设置字段 field.setAccessible(true); get(字段归属的类对象) 获取字段的值 set(字段归属的类对象)]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
        <tag>反射</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js实现当前时间的显示]]></title>
    <url>%2F2019%2F08%2F07%2Fjs%E5%AE%9E%E7%8E%B0%E5%BD%93%E5%89%8D%E6%97%B6%E9%97%B4%E7%9A%84%E6%98%BE%E7%A4%BA%2F</url>
    <content type="text"><![CDATA[直接上代码 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;当前时间&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;当前时间&lt;/p&gt; &lt;p id="now"&gt;&lt;/p&gt; &lt;script&gt; window.onload = function() &#123; var show = document.getElementById("now"); setInterval(function() &#123; var time = new Date(); // 程序计时的月从0开始取值后+1 var m = time.getMonth() + 1; var t = time.getFullYear() + "-" + m + "-" + time.getDate() + " " + time.getHours() + ":" + time.getMinutes() + ":" + time.getSeconds(); show.innerHTML = t; &#125;, 1000); &#125;; &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>小练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS实现倒计时]]></title>
    <url>%2F2019%2F08%2F07%2FJS%E5%AE%9E%E7%8E%B0%E5%80%92%E8%AE%A1%E6%97%B6%2F</url>
    <content type="text"><![CDATA[2020新年倒计时 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;新年倒计时&lt;/p&gt; &lt;p id="demo"&gt;&lt;/p&gt; &lt;script&gt; function g() &#123; var s1 = "2020-01-01 00:00:00" //设置2020年的时间 s1 = new Date(s1.replace(/-/g, "/")); //将'-'换为'/'，也可省掉这步，前边直接写2020/01/01 00:00:00 var s2 = new Date(); //当前时间 //getTime()是获取设置的时间到1970年的毫秒数 var days = s1.getTime() - s2.getTime(); //距新年的毫秒数 //Math.floor() 向下取整数 var day = Math.floor(days / 1000 / 60 / 60 / 24); //得到天 var hour = Math.floor(days / 1000 / 60 / 60 % 24); //得到小时 var mimute = Math.floor(days / 1000 / 60 % 60); //得到分钟 var second = Math.floor(days / 1000 % 60); //得到秒 document.getElementById("demo").innerHTML = day+"天"+hour+"时"+mimute+"分"+second+"秒"; &#125; setInterval(g, 1000); //1秒执行一次g()函数 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>js</tag>
        <tag>小练习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML易忘录]]></title>
    <url>%2F2019%2F07%2F29%2FHTML%2F</url>
    <content type="text"><![CDATA[HTML骨架格式 12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 通用声明HTML5:&lt;!DOCTYPE html&gt; 字符集&lt;meta charset = &quot;UTF-8&quot;&gt; 链接标签&lt;a href=&quot;跳转目标&quot; target=&quot;目标窗口的弹出方式&quot;&gt;链接的文本或图像&lt;/a&gt; target可以设置整体链接代开的状态是以新窗口打开还是在当前窗口中代开。 水平线标签horizontal横线，水平线 &lt;hr /&gt; 换行&lt;br /&gt; 文本格式化标签&lt;b&gt;&lt;/b&gt; &lt;strong&gt;&lt;/strong&gt;加粗 &lt;i&gt;&lt;/i&gt; &lt;em&gt;&lt;/em&gt;斜体 &lt;s&gt;&lt;/s&gt;&lt;del&gt;&lt;/del&gt;删除线 &lt;u&gt;&lt;/u&gt;&lt;ins&gt;&lt;/ins&gt;下划线 锚点定位 在跳转目标位置添加id名标注 使用&lt;a href=&quot;#id名&quot;&gt;链接文本&lt;/a&gt; 1234567&lt;body&gt; &lt;a href="#case1"&gt;1&lt;/a&gt; &lt;div id="case1"&gt; 1 &lt;/div&gt;&lt;/body&gt; 实体字符以“&amp;”开始，“; ”结束。 列表无序列表： 12345&lt;ul&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ...&lt;/ul&gt; 有序列表： 12345&lt;ol&gt; &lt;li&gt;...&lt;/li&gt; &lt;li&gt;...&lt;/li&gt; ...&lt;/ol&gt; 表格基本语法1234567&lt;table&gt; &lt;caption&gt;标题，居中&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;表头，加粗&lt;/th&gt; &lt;td&gt;单元格内容&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 合并单元格 跨行合并：rowspan 跨列合并：colspan 表格标签——属性 表单标签——form&lt;input /&gt;标签为单标签，type属性是其最基本的属性，取值有很多种，用于指定不同的控件类型 表单与表格案例12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;body&gt; &lt;table border="1" align="center"&gt; &lt;caption&gt;表单的应用&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;文本域（u）&lt;/th&gt; &lt;td&gt; &lt;input type="text"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;文本域（u）&lt;/th&gt; &lt;td&gt; &lt;input type="password"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;复选框&lt;/th&gt; &lt;td&gt; 玩游戏&lt;input type="checkbox"&gt; 看电影&lt;input type="checkbox"&gt; 旅游&lt;input type="checkbox"&gt; 看书&lt;input type="checkbox"&gt; 写字&lt;input type="checkbox"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;单选框1&lt;/th&gt; &lt;td&gt; 男&lt;input type="radio" name="sex1" checked&gt; 女&lt;input type="radio" name="sex1"&gt; 保密&lt;input type="radio" name="sex1"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;单选框1&lt;/th&gt; &lt;td&gt; 男&lt;input type="radio" name="sex2" &gt; 女&lt;input type="radio" name="sex2" checked&gt; 保密&lt;input type="radio" name="sex2"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;上传文件&lt;/th&gt; &lt;td&gt; &lt;input type="file"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;下拉列表（s）&lt;/th&gt; &lt;td&gt; &lt;select&gt; &lt;option&gt;刘亦菲&lt;/option&gt; &lt;option&gt;古天乐&lt;/option&gt; &lt;option&gt;刘德华&lt;/option&gt; &lt;option&gt;成龙&lt;/option&gt; &lt;option&gt;李连杰&lt;/option&gt; &lt;/select&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;列表&lt;/th&gt; &lt;td&gt; &lt;textarea&gt; 11111 122222 3333 44444 &lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;多选列表&lt;/th&gt; &lt;td&gt; &lt;textarea rows="8"&gt; 11111 122222 3333 44444 &lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;多行文本域&lt;/th&gt; &lt;td&gt; &lt;textarea rows="5" cols="8" style="width: 150px"&gt; 请输入你的信息 &lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2" align="center"&gt; &lt;input type="submit" name="submit" value="提交"&gt; &lt;input type="reset" name="reset" value="重置"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt;&lt;/body&gt;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>笔记</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java：JDBC编程总结]]></title>
    <url>%2F2019%2F07%2F29%2FJDBC%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JDBC介绍 Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。 持久化：把数据保存到可掉电式存储设备(断电之后，数据还在，比如硬盘，U盘)中以供之后使用。 为什么使用jdbc？ 因为把要数据持久化，持久化数据的最好方式就是把数据保存到数据库，而Java要数据保存到数据，就需要使用JDBC； 使用JDBC获取数据库连接 导包 在项目中新建一个lib文件夹mysql的jar包复制进去，然后右键这个包—&gt;BuildPath。 注册驱动 什么是驱动：操作系统要用电脑上面的硬件（声卡，显卡，网卡），必须安装注册驱动。 简单的说就是一个软件操作硬件。 使用反射注册mysql驱动：Class.forName(“驱动的完全限定名”)。路径：Referenced Liberals-&gt;mysql-connector….jar-&gt;META-INF-&gt;services-&gt;java.sql.Driver。 1Class.forName("com.mysql.cj.jdbc.Driver"); 注意：MySQL8.0和之前版本的区别，首先是驱动换了，不是‘com.mysql.jdbc.Driver’而是’com.mysql.cj.jdbc.Driver’，此外mysql8.0是不需要建立ssl连接的。 128.0之后Class.forName("com.mysql.cj.jdbc.Driver"); 8.0之前Class.forName("com.mysql.jdbc.Driver"); 拿到连接 128.0之后conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/你的数据库名字?useSSL=false&amp;serverTimezone=UTC","root","password"); 8.0之前conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/test_demo","root","password"); 通过DriverManger 驱动管理建立连接(8.0版本)： 1DriverManager.getConnection("jdbc:mysql://localhost:3366/hellomysql?useSSL=false&amp;serverTimezone=UTC", "root", "123"); DAO层做Java来开发，一般吧代码分成很多层，金典的是三层：界面层–业务层–数据层（DAO） DAO：主要用来做数据库的操作 JDBC API executeUpdate(sql) 增删改数据库 ResultSet resultSet = executeQuery(sql) 查询使用此方法 resultSet：操作数据库的角标 rs.next() 角标向下移动一位，返回值为boolean true为有下一个，false为无 close() 关闭连接 使用JDBC执行DDL以删除删除数据为例： 12345678910111213141516171819202122232425262728public static void deleteStock(int id) &#123; Connection conn =null; Statement statement = null; try &#123; //注册mysql驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //获取连接 conn = DriverManager.getConnection("jdbc:mysql://localhost:3366/hellomysql?useSSL=false&amp;serverTimezone=UTC", "root", "123"); //准备操作，准备sql，获取语句执行对象 String sql = "delete from stock where id = "+id; System.out.println(sql); statement = conn.createStatement(); //执行sql statement.executeUpdate(sql); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally &#123; try &#123; statement.close(); conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 查询对象，返回多条数据： 123456789101112131415161718192021public List queryAll() throws Exception &#123; Class.forName("com.mysql.cj.jdbc.Driver"); //2.获取连接 Connection conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/sgr?useSSL=false&amp;serverTimezone=UTC","root","123"); PreparedStatement prepareStatement = conn.prepareStatement("select * from fly"); ResultSet set = prepareStatement.executeQuery(); //ResultSet set = statement.executeQuery("select * from fly"); //当前集合指针向下移动一位 返回boolean值，如果有值，返回true,如果为null返货false List arr = new ArrayList(); while(set.next()) &#123; Fly obj = new Fly(); obj.setId(set.getInt("id")); obj.setPinpai(set.getString("pinpai")); obj.setJiage(set.getDouble("jiage")); arr.add(obj); &#125; return arr;&#125; 重构 对于连接数据的一些参数，我们可以抽取，以后进行修改的时候，只需要改上面的参数就可以了 也可设置配置文件（设置配置文件） 12345678910111213141516public class Config &#123; public static String driverName = "com.mysql.cj.jdbc.Driver"; public static String url = "jdbc:mysql://localhost:3366/hellomysql?useSSL=false&amp;serverTimezone=UTC"; public static String userName = "root"; public static String password = "123";&#125;Class.forName(Config.driverName);//获取连接conn = DriverManager.getConnection(Config.url,Config.userName,Config.password);//准备操作，准备sql，获取语句执行对象conn.setAutoCommit(false);statement = conn.prepareStatement(sql);... 预编译预编译语句PreparedStatement 是java.sql中的一个接口，它是Statement的子接口。通过Statement对象执行SQL语句时，需要将SQL语句发送给DBMS，由 DBMS首先进行编译后再执行。预编译语句和Statement不同，在创建PreparedStatement 对象时就指定了SQL语句，该语句立即发送给DBMS进行编译。当该编译语句被执行时，DBMS直接运行编译后的SQL语句，而不需要像其他SQL语句那样首先将其编译,在执行。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839//数据库连接类static Connection conn = null;static PreparedStatement statement = null;Config config = new Config();public static PreparedStatement getPrepareStatement(String sql) throws Exception &#123; //注册驱动 Class.forName(Config.driverName); //获取连接 conn = DriverManager.getConnection(Config.url,Config.userName,Config.password); //准备操作，准备sql，获取语句执行对象 conn.setAutoCommit(false); statement = conn.prepareStatement(sql); return statement;&#125;//预编译示例，查询登录用户与密码public Login queryLogin(String userName,String password) throws Exception &#123; Login login = new Login(); //获取预处理语句 String sql = "select * from login where userName = ? and password = ?"; //用？代替值 PreparedStatement preparedStatement = JdbcConnection.getPrepareStatement(sql); //这里就把sql传过去 //为预处理的语句设置参数 preparedStatement.setString(1, userName); preparedStatement.setString(2, password); //执行语句 ResultSet set = preparedStatement.executeQuery(); while(set.next()) &#123; login.setUserName(set.getString("userName")); login.setPassword(set.getString("password")); break; &#125; if(login.getUserName() == null || login.getPassword() == null) &#123; return null; &#125;else &#123; return login; &#125; &#125; Java代码操作事务事务：是用户定义的一组操作。这组操作要么都做(都成功)，要么都不做。只要有一个逻辑执行失败，所有数据都回到最初的状态。 事务的ACID属性Atomic原子性、Consistency一致性、Isolation隔离性和Durability持久性。 原子性 指整个事务是不可以分割的工作单元。只有事务中所有的操作执行成功，才算整个事务成功，事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该回到执行事务前的状态。 一致性 指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对于银行转账事务，不管事务成功还是失败，应该保证事务结束后两个转账账户的存款总额是与转账前一致的。 隔离性 指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。 如果没有考虑隔离性，事务面临的问题： ​ 读：脏读，幻想、读，不可重复读 ​ 写：第一类数据丢失，第二类数据丢失 持久性 指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。 事务处理的两个动作 提交：commit 当整个事务中，所有的逻辑单元都正常执行成功—&gt;提交事务。 数据已经提交，不能更改。 回滚：rollback 当整个事务中，有一个逻辑单元执行失败—&gt;回滚事务。 撤销该事务中的所有操作—&gt;恢复到最初的状态。 APIJAVA中事务对象的处理由连接对象而来 在JDBC中,事务是默认提交的，必须先设置事务为手动提交。 手动的提交事务。 若出现异常必须回滚事务，若不回滚事务，不会释放数据库资源。 关闭自动提交：java.sql.Connection.setAutoCommit(false) 手动提交事务：.commit(); 回滚：.rollback(); 关闭连接：.close(); 代码示例： 123456789101112131415161718192021222324252627282930313233343536static Connection conn = null;static Connection conn2 = null;static PreparedStatement ps = null;@Testpublic void testName() &#123; try &#123; conn = JDBCConnection.dataSource(); //连接 conn2 = JDBCConnection.dataSource(); conn.setAutoCommit(false); //关闭自动提交 String sql = "insert into bank values(null,?,?)"; ps = conn.prepareStatement(sql); ps.setString(1, "尹志平"); ps.setInt(2, 10000); ps.executeUpdate();// int a = 10/0; //设置一个异常来测试 ps.setString(1, "郭靖"); ps.setInt(2, 10000); ps.executeUpdate(); conn.commit(); //成功，提交事务 &#125; catch (Exception e) &#123; try &#123; conn.rollback(); //事变：回滚事务 &#125; catch (SQLException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; &#125;finally &#123; try &#123; JDBCConnection.close(conn, ps); //关闭连接 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 注意： 在JDBC中事务是默认提交的，在执行一个DML/DDL操作的时候，就已经提交事务了。 事务只是针对连接连接对象，如果再开一个连接对象，那么那是默认的提交。 针对于CRUD操作。只有DML操作才有事务,查询操作没有事务。但是，我们一般会把查询也放在事务里面。 MySQL中，InnoDB支持外键。支持事务，MyISAM不支持外键，不支持事务。 数据库连接池目的：不用多次创建连接 一开始先在内存中开辟一块空间（集合），往池子里面放置多个连接对象。后面需要连接的话，直接从池子里面取。不要去自己创建连接了。使用完毕，要记得归还连接。确保连接对象能循环利用。 开源连接池 第三方连接池：DBCP、C3P0等 以C3P0为例 复制jar文件到lib目录（c3p0-0.9.1.2.jar） 创建数据源new DataSource() 配置信息设置 获取连接 代码示例 1234567891011121314151617181920212223242526Connection conn = null;PreparedStatement ps = null;try &#123; //1. 创建datasource ComboPooledDataSource dataSource = new ComboPooledDataSource(); //2. 设置连接数据的信息 dataSource.setDriverClass("com.mysql.jc.jdbc.Driver"); dataSource.setJdbcUrl("jdbc:mysql://localhost:3366/hellomysql?useSSL=false&amp;serverTimezone=UTC"); dataSource.setUser("root"); dataSource.setPassword("123"); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = "insert into account values(null , ? , ?)"; ps = conn.prepareStatement(sql); ps.setString(1, "admi234n"); ps.setInt(2, 103200); ps.executeUpdate();&#125; catch (Exception e) &#123; e.printStackTrace();&#125;finally &#123; JDBCUtil.release(conn, ps); &#125; 注意：自定义数据库连接池中，调用的close()方法不是真的关闭，而是归还连接对象。 单独设置一个类放连接池： 123456789101112131415161718static Connection conn = null;static PreparedStatement ps = null;public static Connection dataSource() throws Exception &#123; //创建dataSource ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass("com.mysql.cj.jdbc.Driver"); dataSource.setJdbcUrl("jdbc:mysql://localhost:3366/hellomysql?useSSL=false&amp;serverTimezone=UTC"); dataSource.setUser("root"); dataSource.setPassword("123"); dataSource.setMaxPoolSize(200); //设置最大连接数 dataSource.setMinPoolSize(1); //最小连接数 dataSource.setInitialPoolSize(1); //设置初始池大小 dataSource.setMaxIdleTime(5000); //设置最大延迟时间 return dataSource.getConnection();&#125; DBUtils 开源，免费的ORM框架。 dbutils 只是帮我们简化了CRUD 的代码， 但是连接的创建以及获取工作。 不在他的考虑范围。 导入jar文件。 核心对象 new QueryRunner(连接池) 核心对象 new QueryRunner().update(连接对象,sql,预编译参数) 查询语句 new QueryRunner().query(连接对象,sql,预编译参数,返回封装类型) 返回值类型认识： BeanHandler，查询到的单个数据封装成一个对象BeanListHandler，查询到的多个数据封装 成一个List&lt;对象&gt;ArrayHandler，查询到的单个数据封装成一个数组ArrayListHandler，查询到的多个数据封装成一个集合 ，集合里面的元素是数组。MapHandler，查询到的单个数据封装成一个mapMapListHandler，查询到的多个数据封装成一个集合 ，集合里面的元素是map。 代码示例： 修改： 123Connection conn = JDBCConnection.dataSource();new QueryRunner().update(conn4,"update bank set money = ? where name = ?",10000,"雕兄"); //以改为例conn.close(); 查询： 1234567891011@Testpublic void testName() throws Exception &#123; Connection conn1 = JDBCConnection.dataSource(); List&lt;Object[]&gt; list = new QueryRunner().query(conn1, "select * from bank",new ArrayListHandler()); for (Object[] objects : list) &#123; for (Object e : objects) &#123; System.out.print(e+"--"); &#125; System.out.println(); &#125;&#125; 设置配置文件（扩展） 在src目录下新建一个connection.properties文件 里面写上配置信息： 12345678driverClass=com.mysql.cj.jdbc.DriverjdbcUrl=jdbc:mysql://localhost:3366/hellomysql?useSSL=false&amp;serverTimezone=UTCuser=rootpassword=123maxPoolSize=200minPoolSize=1initialPoolSize=1maxIdleTime=5000 调用配置文件 123456789101112131415161718192021222324252627282930313233public class JDBCConnection &#123; static Connection conn = null; static PreparedStatement ps = null; public static Connection dataSource() throws Exception &#123; Properties properties = new Properties(); //获取Properties实例 InputStream inputStream = new FileInputStream("src//connection.properties"); //获取配置文件输入流 properties.load(inputStream); //载入输入流 //获取配置文件里面的值 string类型 String driverClass = properties.getProperty("driverClass"); String jdbcUrl = properties.getProperty("jdbcUrl"); String user = properties.getProperty("user"); String password = properties.getProperty("password"); //int类型 int maxPoolSize = Integer.parseInt(properties.getProperty("maxPoolSize")); int minPoolSize = Integer.parseInt(properties.getProperty("minPoolSize")); int initialPoolSize = Integer.parseInt(properties.getProperty("initialPoolSize")); int maxIdleTime = Integer.parseInt(properties.getProperty("maxIdleTime")); ComboPooledDataSource dataSource = new ComboPooledDataSource(); //将获取到的参数填进去 dataSource.setDriverClass(driverClass); dataSource.setJdbcUrl(jdbcUrl); dataSource.setUser(user); dataSource.setPassword(password); dataSource.setMaxPoolSize(maxPoolSize); dataSource.setMinPoolSize(minPoolSize); dataSource.setInitialPoolSize(initialPoolSize); dataSource.setMaxIdleTime(maxIdleTime); return dataSource.getConnection();&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于线程的一些总结]]></title>
    <url>%2F2019%2F07%2F23%2F%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程概述 进程就是在某种程度上相互隔离的、独立运行的程序，可以看成是正在运行的一大段代码 进程是线程的容器 线程概述 线程有时称为轻量级进程 是程序执行顺序流的最小单元 进程看成是一大段代码，那么一个线程可以看成是一小段代码 一个进程中可以有多个线程组成，最少有1个 多线程 在单个程序中同时运行多个线程以完成不同的工作 线程与进程的区别： 地址空间和其他资源（如打开文件）：进程间相互独立，同一进程的各线程间共享；某进程内的线程在其他进程不可见。 通信：线程间可以通过直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性 调度和切换：线程上下文切换比进程上下文切换快得多 在多线程OS中，进程不是一个可执行的实体。 创建线程 方式一：创建启动线程（继承Thread类） 类继承了线程类Thread，并且覆盖它的run()方法。 主函数中调用start()方法开启线程。调用start()方法将会启动这个线程，并在获得CPU时间的时候调用run()方法，执行run()的方法体。 注意：如果直接通过该线程对象调用run()方法，线程并没有开启，调用过程仍是由主线程完成的。 方式二：实现Runnable接口方式创建线程 自定义类实现Runnable接口，并且在类中实现Runnable接口中的run()方法。 在main()方法中创建一个rt对象，并将这个对象当作Thread构造器的参数创建一个Thread对象，最后调用Thread对象的start()方法。 多线程并发 使用synchronized关键字 使用到synchronized 直接修饰一个方法就可以了； 位置，在方法的返回值类型前面； 同步方法不需要写同步监听对象，实例方法（非static修饰）默认同步监听对象是this; 同步方法不需要写同步监听对象，静态方法（有static修饰）默认同步监听对象是当前类所在的字节码对象 Xxx.class synchronize(**.class){…} 12345synchronize（同步监听对象）&#123;​ 需要被同步的代码（有线程安全问题的代码）&#125; 锁机制 1、ReentrantLock类是可重入、互斥、实现了Lock接口的锁 2、ReentrantLock() lock(); //获得锁 unlock(); //释放锁 这两种方法的代码： 12345678910111213141516171819202122232425262728293031public class TicketThread implements Runnable&#123; private int num = 50; private String name; public static final Lock lock = new ReentrantLock(); public TicketThread(String name)&#123; this.name = name; &#125; @Override public void run() &#123; while (num&gt;0)&#123; lock.lock(); try&#123; if(num&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"当前票号是："+num); num--; &#125; &#125;finally &#123; lock.unlock(); &#125; &#125; &#125; /* synchronized private void saleOne() &#123; if(num&gt;0)&#123; System.out.println(getName()+"当前票号是："+num); num--; &#125; &#125;*/&#125; 定时器sleep()123456789101112public class TestSleep1 extends Thread &#123; @Override public void run() &#123; try &#123; System.out.println(this.currentThread().getName()+"开始"); Thread.sleep(2000); //延时2秒 System.out.println(this.currentThread().getName()+"爆炸"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 线程常用的方法 Thread(&quot;线程对象&quot;,&quot;线程定义名字&quot;) ； 构造方法 a.start(); 启动线程 a.currentThread(); 获取当前线程 a.currentThread().getName(); 获得名字 a.isAlive(); 判断线程是否处于存活状态 a.sleep(); 线程延迟（睡眠） a.getId(); 取得线程的唯一标识 守护线程 守护线程与普通线程的唯一区别是：当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则不会退出。 特点：用户线程结束，守护线程跟着结束 作用：通常用于服务程序，服务主线程程序 isDeamon(); 是否为守护线程 setDeamon(true); 设置为守护线程 线程等待与唤醒 synchronized等待唤醒机制主要指的是notify()/notifyAll()和wait()方法 在使用这3个方法时，必须处于synchronized代码块或者synchronized方法中，否则就会抛出IllegalMonitorStateException异常。 wait()：让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。 notify()：唤醒在此对象监视器上等待的单个线程。 notifyAll()：唤醒在此对象监视器上等待的所有线程。 12345678910111213141516171819202122232425262728293031public class WaitThread extends Thread&#123; public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1");// WaitThread t1 = new WaitThread(); synchronized (t1)&#123; try&#123; System.out.println(Thread.currentThread().getName()+" start t1"); t1.start(); System.out.println(Thread.currentThread().getName()+" wait()"); t1.wait(); System.out.println(Thread.currentThread().getName()+" continue()"); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super (name); &#125; @Override public void run() &#123; synchronized (this)&#123; System.out.println(Thread.currentThread().getName()+" call notify()"); notify(); &#125; &#125;&#125; 执行结果： 1234main start t1main wait()t1 call notify()main continue() Timer定时器 这个方法是调度一个task，在delay（ms）后开始调度，每次调度完后，最少等待period（ms）后才开始调度。 timer.schedule(task,1000/date,2000); 使用： 创建一个Timer对象； 调用里面的设置时间和任务的方法： void schedule(TimerTask task, long delay) 安排在指定延迟后执行指定的任务 自定义一个类 extends TimerTask 覆写TimerTask 中的run方法 运行程序]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>笔记</tag>
        <tag>Java</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
