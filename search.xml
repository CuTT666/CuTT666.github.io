<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java：JDBC编程总结]]></title>
    <url>%2F2019%2F07%2F29%2FJava%EF%BC%9AJDBC%E7%BC%96%E7%A8%8B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[JDBC介绍 Java数据库连接，（Java Database Connectivity，简称JDBC）是Java语言中用来规范客户端程序如何来访问数据库的应用程序接口，提供了诸如查询和更新数据库中数据的方法。 持久化：把数据保存到可掉电式存储设备(断电之后，数据还在，比如硬盘，U盘)中以供之后使用。 为什么使用jdbc？ 因为把要数据持久化，持久化数据的最好方式就是把数据保存到数据库，而Java要数据保存到数据，就需要使用JDBC； 使用JDBC获取数据库连接 导包 在项目中新建一个lib文件夹mysql的jar包复制进去，然后右键这个包—&gt;BuildPath。 注册驱动 什么是驱动：操作系统要用电脑上面的硬件（声卡，显卡，网卡），必须安装注册驱动。 简单的说就是一个软件操作硬件。 使用反射注册mysql驱动：Class.forName(“驱动的完全限定名”)。路径：Referenced Liberals-&gt;mysql-connector….jar-&gt;META-INF-&gt;services-&gt;java.sql.Driver。 1Class.forName("com.mysql.cj.jdbc.Driver"); 注意：MySQL8.0和之前版本的区别，首先是驱动换了，不是‘com.mysql.jdbc.Driver’而是’com.mysql.cj.jdbc.Driver’，此外mysql8.0是不需要建立ssl连接的。 128.0之后Class.forName("com.mysql.cj.jdbc.Driver"); 8.0之前Class.forName("com.mysql.jdbc.Driver"); 拿到连接 128.0之后conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/你的数据库名字?useSSL=false&amp;serverTimezone=UTC","root","password"); 8.0之前conn = DriverManager.getConnection("jdbc:mysql://localhost:3306/test_demo","root","password"); 通过DriverManger 驱动管理建立连接(8.0版本)： 1DriverManager.getConnection("jdbc:mysql://localhost:3366/hellomysql?useSSL=false&amp;serverTimezone=UTC", "root", "123"); DAO层做Java来开发，一般吧代码分成很多层，金典的是三层：界面层–业务层–数据层（DAO） DAO：主要用来做数据库的操作 JDBC API executeUpdate(sql) 增删改数据库 ResultSet resultSet = executeQuery(sql) 查询使用此方法 resultSet：操作数据库的角标 rs.next() 角标向下移动一位，返回值为boolean true为有下一个，false为无 close() 关闭连接 使用JDBC执行DDL以删除删除数据为例： 12345678910111213141516171819202122232425262728public static void deleteStock(int id) &#123; Connection conn =null; Statement statement = null; try &#123; //注册mysql驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //获取连接 conn = DriverManager.getConnection("jdbc:mysql://localhost:3366/hellomysql?useSSL=false&amp;serverTimezone=UTC", "root", "123"); //准备操作，准备sql，获取语句执行对象 String sql = "delete from stock where id = "+id; System.out.println(sql); statement = conn.createStatement(); //执行sql statement.executeUpdate(sql); &#125; catch (Exception e) &#123; // TODO: handle exception e.printStackTrace(); &#125;finally &#123; try &#123; statement.close(); conn.close(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125;&#125; 查询对象，返回多条数据 123456789101112131415161718192021public List queryAll() throws Exception &#123; Class.forName(&quot;com.mysql.cj.jdbc.Driver&quot;); //2.获取连接 Connection conn = DriverManager.getConnection(&quot;jdbc:mysql://localhost:3306/sgr?useSSL=false&amp;serverTimezone=UTC&quot;,&quot;root&quot;,&quot;123&quot;); PreparedStatement prepareStatement = conn.prepareStatement(&quot;select * from fly&quot;); ResultSet set = prepareStatement.executeQuery(); //ResultSet set = statement.executeQuery(&quot;select * from fly&quot;); //当前集合指针向下移动一位 返回boolean值，如果有值，返回true,如果为null返货false List arr = new ArrayList(); while(set.next()) &#123; Fly obj = new Fly(); obj.setId(set.getInt(&quot;id&quot;)); obj.setPinpai(set.getString(&quot;pinpai&quot;)); obj.setJiage(set.getDouble(&quot;jiage&quot;)); arr.add(obj); &#125; return arr;&#125; 重构对于连接数据的一些参数，我们可以抽取，以后进行修改的时候方法，只需要改上面的参数就可以了 12345678910111213141516public class Config &#123; public static String driverName = "com.mysql.cj.jdbc.Driver"; public static String url = "jdbc:mysql://localhost:3366/hellomysql?useSSL=false&amp;serverTimezone=UTC"; public static String userName = "root"; public static String password = "123";&#125;Class.forName(Config.driverName);//获取连接conn = DriverManager.getConnection(Config.url,Config.userName,Config.password);//准备操作，准备sql，获取语句执行对象conn.setAutoCommit(false);statement = conn.prepareStatement(sql);... 123456789101112131415161718192021222324import java.sql.Connection;import java.sql.DriverManager;import java.sql.Statement;public class JdbcConnection &#123; static Connection conn = null; static Statement statement = null; public static Statement getStatement() throws Exception &#123; //注册驱动 Class.forName("com.mysql.cj.jdbc.Driver"); //获取连接 conn = DriverManager.getConnection("jdbc:mysql://localhost:3366/hellomysql?useSSL=false&amp;serverTimezone=UTC", "root", "123"); //准备操作，准备sql，获取语句执行对象 statement = conn.createStatement(); return statement; &#125; public static void close() throws Exception &#123; statement.close(); conn.close(); &#125;&#125; 预编译预编译语句PreparedStatement 是java.sql中的一个接口，它是Statement的子接口。通过Statement对象执行SQL语句时，需要将SQL语句发送给DBMS，由 DBMS首先进行编译后再执行。预编译语句和Statement不同，在创建PreparedStatement 对象时就指定了SQL语句，该语句立即发送给DBMS进行编译。当该编译语句被执行时，DBMS直接运行编译后的SQL语句，而不需要像其他SQL语句那样首先将其编译,在执行。 代码示例： 123456789101112131415161718192021222324252627282930313233343536373839//数据库连接类static Connection conn = null;static PreparedStatement statement = null;Config config = new Config();public static PreparedStatement getPrepareStatement(String sql) throws Exception &#123; //注册驱动 Class.forName(Config.driverName); //获取连接 conn = DriverManager.getConnection(Config.url,Config.userName,Config.password); //准备操作，准备sql，获取语句执行对象 conn.setAutoCommit(false); statement = conn.prepareStatement(sql); return statement;&#125;//预编译示例，查询登录用户与密码public Login queryLogin(String userName,String password) throws Exception &#123; Login login = new Login(); //获取预处理语句 String sql = "select * from login where userName = ? and password = ?"; //用？代替值 PreparedStatement preparedStatement = JdbcConnection.getPrepareStatement(sql); //这里就把sql传过去 //为预处理的语句设置参数 preparedStatement.setString(1, userName); preparedStatement.setString(2, password); //执行语句 ResultSet set = preparedStatement.executeQuery(); while(set.next()) &#123; login.setUserName(set.getString("userName")); login.setPassword(set.getString("password")); break; &#125; if(login.getUserName() == null || login.getPassword() == null) &#123; return null; &#125;else &#123; return login; &#125; &#125; Java代码操作事务事务：是用户定义的一组操作。这组操作要么都做(都成功)，要么都不做。只要有一个逻辑执行失败，所有数据都回到最初的状态。 事务的ACID属性Atomic原子性、Consistency一致性、Isolation隔离性和Durability持久性。 原子性 指整个事务是不可以分割的工作单元。只有事务中所有的操作执行成功，才算整个事务成功，事务中任何一个SQL语句执行失败，那么已经执行成功的SQL语句也必须撤销，数据库状态应该回到执行事务前的状态。 一致性 指数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。例如对于银行转账事务，不管事务成功还是失败，应该保证事务结束后两个转账账户的存款总额是与转账前一致的。 隔离性 指的是在并发环境中，当不同的事务同时操纵相同的数据时，每个事务都有各自的完整数据空间。 如果没有考虑隔离性，事务面临的问题： ​ 读：脏读，幻想、读，不可重复读 ​ 写：第一类数据丢失，第二类数据丢失 持久性 指的是只要事务成功结束，它对数据库所做的更新就必须永久保存下来。即使发生系统崩溃，重新启动数据库系统后，数据库还能恢复到事务成功结束时的状态。 事务处理的两个动作 提交：commit 当整个事务中，所有的逻辑单元都正常执行成功—&gt;提交事务。 数据已经提交，不能更改。 回滚：rollback 当整个事务中，有一个逻辑单元执行失败—&gt;回滚事务。 撤销该事务中的所有操作—&gt;恢复到最初的状态。 APIJAVA中事务对象的处理由连接对象而来 在JDBC中,事务是默认提交的，必须先设置事务为手动提交。 手动的提交事务。 若出现异常必须回滚事务，若不回滚事务，不会释放数据库资源。 关闭自动提交：java.sql.Connection.setAutoCommit(false) 手动提交事务：.commit(); 回滚：.rollback(); 关闭连接：.close(); 代码示例： 123456789101112131415161718192021222324252627282930313233343536static Connection conn = null;static Connection conn2 = null;static PreparedStatement ps = null;@Testpublic void testName() &#123; try &#123; conn = JDBCConnection.dataSource(); //连接 conn2 = JDBCConnection.dataSource(); conn.setAutoCommit(false); //关闭自动提交 String sql = "insert into bank values(null,?,?)"; ps = conn.prepareStatement(sql); ps.setString(1, "尹志平"); ps.setInt(2, 10000); ps.executeUpdate();// int a = 10/0; //设置一个异常来测试 ps.setString(1, "郭靖"); ps.setInt(2, 10000); ps.executeUpdate(); conn.commit(); //成功，提交事务 &#125; catch (Exception e) &#123; try &#123; conn.rollback(); //事变：回滚事务 &#125; catch (SQLException e1) &#123; // TODO Auto-generated catch block e1.printStackTrace(); &#125; &#125;finally &#123; try &#123; JDBCConnection.close(conn, ps); //关闭连接 &#125; catch (Exception e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; 注意： 在JDBC中事务是默认提交的，在执行一个DML/DDL操作的时候，就已经提交事务了。 事务只是针对连接连接对象，如果再开一个连接对象，那么那是默认的提交。 针对于CRUD操作。只有DML操作才有事务,查询操作没有事务。但是，我们一般会把查询也放在事务里面。 MySQL中，InnoDB支持外键。支持事务，MyISAM不支持外键，不支持事务。 数据库连接池目的：不用多次创建连接 一开始先在内存中开辟一块空间（集合），往池子里面放置多个连接对象。后面需要连接的话，直接从池子里面取。不要去自己创建连接了。使用完毕，要记得归还连接。确保连接对象能循环利用。 开源连接池 第三方连接池：DBCP、C3P0等 以C3P0为例 复制jar文件到lib目录（c3p0-0.9.1.2.jar） 创建数据源new DataSource() 配置信息设置 获取连接 代码示例 1234567891011121314151617181920212223242526Connection conn = null;PreparedStatement ps = null;try &#123; //1. 创建datasource ComboPooledDataSource dataSource = new ComboPooledDataSource(); //2. 设置连接数据的信息 dataSource.setDriverClass("com.mysql.jc.jdbc.Driver"); dataSource.setJdbcUrl("jdbc:mysql://localhost:3366/hellomysql?useSSL=false&amp;serverTimezone=UTC"); dataSource.setUser("root"); dataSource.setPassword("123"); //2. 得到连接对象 conn = dataSource.getConnection(); String sql = "insert into account values(null , ? , ?)"; ps = conn.prepareStatement(sql); ps.setString(1, "admi234n"); ps.setInt(2, 103200); ps.executeUpdate();&#125; catch (Exception e) &#123; e.printStackTrace();&#125;finally &#123; JDBCUtil.release(conn, ps); &#125; 注意：自定义数据库连接池中，调用的close()方法不是真的关闭，而是归还连接对象。 单独设置一个类放连接池： 123456789101112131415161718static Connection conn = null;static PreparedStatement ps = null;public static Connection dataSource() throws Exception &#123; //创建dataSource ComboPooledDataSource dataSource = new ComboPooledDataSource(); dataSource.setDriverClass("com.mysql.cj.jdbc.Driver"); dataSource.setJdbcUrl("jdbc:mysql://localhost:3366/hellomysql?useSSL=false&amp;serverTimezone=UTC"); dataSource.setUser("root"); dataSource.setPassword("123"); dataSource.setMaxPoolSize(200); //设置最大连接数 dataSource.setMinPoolSize(1); //最小连接数 dataSource.setInitialPoolSize(1); //设置初始池大小 dataSource.setMaxIdleTime(5000); //设置最大延迟时间 return dataSource.getConnection();&#125; DBUtils 开源，免费的ORM框架。 dbutils 只是帮我们简化了CRUD 的代码， 但是连接的创建以及获取工作。 不在他的考虑范围。 导入jar文件。 核心对象 new QueryRunner(连接池) 核心对象 new QueryRunner().update(连接对象,sql,预编译参数) 查询语句 new QueryRunner().query(连接对象,sql,预编译参数,返回封装类型) 返回值类型认识： BeanHandler，查询到的单个数据封装成一个对象BeanListHandler，查询到的多个数据封装 成一个List&lt;对象&gt;ArrayHandler，查询到的单个数据封装成一个数组ArrayListHandler，查询到的多个数据封装成一个集合 ，集合里面的元素是数组。MapHandler，查询到的单个数据封装成一个mapMapListHandler，查询到的多个数据封装成一个集合 ，集合里面的元素是map。 代码示例： 修改： 123Connection conn = JDBCConnection.dataSource();new QueryRunner().update(conn4,"update bank set money = ? where name = ?",10000,"雕兄"); //以改为例conn.close(); 查询： 1234567891011@Testpublic void testName() throws Exception &#123; Connection conn1 = JDBCConnection.dataSource(); List&lt;Object[]&gt; list = new QueryRunner().query(conn1, "select * from bank",new ArrayListHandler()); for (Object[] objects : list) &#123; for (Object e : objects) &#123; System.out.print(e+"--"); &#125; System.out.println(); &#125;&#125; 设置配置文件（扩展） 在src目录下新建一个connection.properties文件 里面写上配置信息： 12345678driverClass=com.mysql.cj.jdbc.DriverjdbcUrl=jdbc:mysql://localhost:3366/hellomysql?useSSL=false&amp;serverTimezone=UTCuser=rootpassword=123maxPoolSize=200minPoolSize=1initialPoolSize=1maxIdleTime=5000 调用配置文件 123456789101112131415161718192021222324252627282930313233public class JDBCConnection &#123; static Connection conn = null; static PreparedStatement ps = null; public static Connection dataSource() throws Exception &#123; Properties properties = new Properties(); //获取Properties实例 InputStream inputStream = new FileInputStream("src//connection.properties"); //获取配置文件输入流 properties.load(inputStream); //载入输入流 //获取配置文件里面的值 string类型 String driverClass = properties.getProperty("driverClass"); String jdbcUrl = properties.getProperty("jdbcUrl"); String user = properties.getProperty("user"); String password = properties.getProperty("password"); //int类型 int maxPoolSize = Integer.parseInt(properties.getProperty("maxPoolSize")); int minPoolSize = Integer.parseInt(properties.getProperty("minPoolSize")); int initialPoolSize = Integer.parseInt(properties.getProperty("initialPoolSize")); int maxIdleTime = Integer.parseInt(properties.getProperty("maxIdleTime")); ComboPooledDataSource dataSource = new ComboPooledDataSource(); //将获取到的参数填进去 dataSource.setDriverClass(driverClass); dataSource.setJdbcUrl(jdbcUrl); dataSource.setUser(user); dataSource.setPassword(password); dataSource.setMaxPoolSize(maxPoolSize); dataSource.setMinPoolSize(minPoolSize); dataSource.setInitialPoolSize(initialPoolSize); dataSource.setMaxIdleTime(maxIdleTime); return dataSource.getConnection();&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于线程的一些总结]]></title>
    <url>%2F2019%2F07%2F23%2F%E7%BA%BF%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[进程概述 进程就是在某种程度上相互隔离的、独立运行的程序，可以看成是正在运行的一大段代码 进程是线程的容器 线程概述 线程有时称为轻量级进程 是程序执行顺序流的最小单元 进程看成是一大段代码，那么一个线程可以看成是一小段代码 一个进程中可以有多个线程组成，最少有1个 多线程 在单个程序中同时运行多个线程以完成不同的工作 线程与进程的区别： 地址空间和其他资源（如打开文件）：进程间相互独立，同一进程的各线程间共享；某进程内的线程在其他进程不可见。 通信：线程间可以通过直接读写进程数据段（如全局变量）来进行通信——需要进程同步和互斥手段的辅助，以保证数据的一致性 调度和切换：线程上下文切换比进程上下文切换快得多 在多线程OS中，进程不是一个可执行的实体。 创建线程 方式一：创建启动线程（继承Thread类） 类继承了线程类Thread，并且覆盖它的run()方法。 主函数中调用start()方法开启线程。调用start()方法将会启动这个线程，并在获得CPU时间的时候调用run()方法，执行run()的方法体。 注意：如果直接通过该线程对象调用run()方法，线程并没有开启，调用过程仍是由主线程完成的。 方式二：实现Runnable接口方式创建线程 自定义类实现Runnable接口，并且在类中实现Runnable接口中的run()方法。 在main()方法中创建一个rt对象，并将这个对象当作Thread构造器的参数创建一个Thread对象，最后调用Thread对象的start()方法。 多线程并发 使用synchronized关键字 使用到synchronized 直接修饰一个方法就可以了； 位置，在方法的返回值类型前面； 同步方法不需要写同步监听对象，实例方法（非static修饰）默认同步监听对象是this; 同步方法不需要写同步监听对象，静态方法（有static修饰）默认同步监听对象是当前类所在的字节码对象 Xxx.class synchronize(**.class){…} 12345synchronize（同步监听对象）&#123;​ 需要被同步的代码（有线程安全问题的代码）&#125; 锁机制 1、ReentrantLock类是可重入、互斥、实现了Lock接口的锁 2、ReentrantLock() lock(); //获得锁 unlock(); //释放锁 这两种方法的代码： 12345678910111213141516171819202122232425262728293031public class TicketThread implements Runnable&#123; private int num = 50; private String name; public static final Lock lock = new ReentrantLock(); public TicketThread(String name)&#123; this.name = name; &#125; @Override public void run() &#123; while (num&gt;0)&#123; lock.lock(); try&#123; if(num&gt;0)&#123; System.out.println(Thread.currentThread().getName()+"当前票号是："+num); num--; &#125; &#125;finally &#123; lock.unlock(); &#125; &#125; &#125; /* synchronized private void saleOne() &#123; if(num&gt;0)&#123; System.out.println(getName()+"当前票号是："+num); num--; &#125; &#125;*/&#125; 定时器sleep()123456789101112public class TestSleep1 extends Thread &#123; @Override public void run() &#123; try &#123; System.out.println(this.currentThread().getName()+"开始"); Thread.sleep(2000); //延时2秒 System.out.println(this.currentThread().getName()+"爆炸"); &#125;catch (InterruptedException e)&#123; e.printStackTrace(); &#125; &#125;&#125; 线程常用的方法 Thread(“线程对象”,”线程定义名字”) ； 构造方法 a.start(); 启动线程 a.currentThread(); 获取当前线程 a.currentThread().getName(); 获得名字 a.isAlive(); 判断线程是否处于存活状态 a.sleep(); 线程延迟（睡眠） a.getId(); 取得线程的唯一标识 守护线程 守护线程与普通线程的唯一区别是：当JVM中所有的线程都是守护线程的时候，JVM就可以退出了；如果还有一个或以上的非守护线程则不会退出。 特点：用户线程结束，守护线程跟着结束 作用：通常用于服务程序，服务主线程程序 isDeamon(): 是否为守护线程 setDeamon(true); 设置为守护线程 线程等待与唤醒 synchronized等待唤醒机制主要指的是notify()/notifyAll()和wait()方法 在使用这3个方法时，必须处于synchronized代码块或者synchronized方法中，否则就会抛出IllegalMonitorStateException异常。 wait()：让当前线程进入等待状态，同时，wait()也会让当前线程释放它所持有的锁。 notify()：唤醒在此对象监视器上等待的单个线程。 notifyAll()：唤醒在此对象监视器上等待的所有线程。 12345678910111213141516171819202122232425262728293031public class WaitThread extends Thread&#123; public static void main(String[] args) &#123; ThreadA t1 = new ThreadA("t1");// WaitThread t1 = new WaitThread(); synchronized (t1)&#123; try&#123; System.out.println(Thread.currentThread().getName()+" start t1"); t1.start(); System.out.println(Thread.currentThread().getName()+" wait()"); t1.wait(); System.out.println(Thread.currentThread().getName()+" continue()"); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125;class ThreadA extends Thread&#123; public ThreadA(String name)&#123; super (name); &#125; @Override public void run() &#123; synchronized (this)&#123; System.out.println(Thread.currentThread().getName()+" call notify()"); notify(); &#125; &#125;&#125; 执行结果： 1234main start t1main wait()t1 call notify()main continue() Timer定时器 这个方法是调度一个task，在delay（ms）后开始调度，每次调度完后，最少等待period（ms）后才开始调度。 timer.schedule(task,1000/date,2000); 使用： 创建一个Timer对象； 调用里面的设置时间和任务的方法： void schedule(TimerTask task, long delay) 安排在指定延迟后执行指定的任务 自定义一个类 extends TimerTask 覆写TimerTask 中的run方法 运行程序]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>笔记</tag>
        <tag>线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F07%2F20%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
